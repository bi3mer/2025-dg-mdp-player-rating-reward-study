from typing import List, cast
import json
import os

from GDM.GDM.Graph import Graph, Node, Edge
from GDM.GDM.utility import bfs

############# TYpes for the graph #############
class N(Node):
    def __init__(self, name: str, diff: float, enj: float, is_terminal: bool):
        super().__init__(name, 0, 0, False, set())
        self.d = diff
        self.e = enj
        self.depth = 0 # Will be set later

    def to_typescript(self) -> str:
        return f"MDP.addNode(new CustomNode('{self.name}', {self.d}, {self.e}, 0, false, [], {self.depth}));\n"

class E(Edge):
    def __init__(self, src: str, tgt: str, link: List[str]):
        super().__init__(src, tgt, [])
        self.link = link

    def to_typescript(self) -> str:
        return f'MDP.addEdge(new CustomEdge("{self.src}", "{self.tgt}", [["{self.tgt}", 0.99], [KEY_DEATH, 0.01]], {self.link}));\n'

G = Graph()

############# Get Links and Levels #############
with open(os.path.join("..", "data", "links.json"), "r") as f:
    links = json.load(f)

with open(os.path.join("..", "data", "levels.json"), "r") as f:
    levels = json.load(f)

    keys = list(levels.keys())
    for id in keys:
        levels[f"{id}_0"] = [row[2:-2] for row in levels[id]]
        del levels[id]


############# Add nodes to the graph #############
with open(os.path.join("..", "data", "level_to_stats.csv"), "r") as f:
    f.readline()  # skip first line
    for line in f.readlines():
        id, difficulty, enjoyability = line.strip().split(",")
        d = float(difficulty) / 7 - 1
        e = float(enjoyability) / 7 - 1
        G.add_node(N(f'{id}_0', d, e, False))

# Remove nodes that are terminal
nodes_to_remove = []
for level_id in G.nodes:
    is_terminal = True
    linkKey = level_id.replace("_", ",")
    for tgt in links[linkKey]:
        if links[linkKey][tgt]["tree search"]["percent_playable"] == 1.0:
            is_terminal = False
            break

    if is_terminal:
        print(f"{level_id} is terminal :/")
        nodes_to_remove.append(level_id)

while len(nodes_to_remove) > 0:
    G.remove_node(nodes_to_remove.pop())

############# Build Edges that are Usable #############
for src in links:
    _src = src.replace(",", "_")
    if _src not in G.nodes:
        continue

    for tgt in links[src]:
        info = links[src][tgt]
        tgt = tgt.replace(",", "_")

        if (
            tgt in G.nodes
            and info["tree search"]["percent_playable"] == 1.0
        ):
            G.add_edge(E(_src, tgt, info["tree search"]["link"]) )

############# Run BFS to get thhe depth each node #############
for node_name in G.nodes:
    cast(N, G.nodes[node_name]).depth = len(bfs(G, '0_0_0', node_name)[1])

############# Convert Graph into TypeScript #############
typescript = "// Generated by ../scripts/make_gdm_graph.py.py\n"
typescript += 'import { Graph } from "./GDM-TS";\n'
typescript += 'import { CustomNode } from "./customNode";\n'
typescript += 'import { CustomEdge } from "./customEdge";\n'
typescript += 'import { KEY_DEATH, KEY_START } from "./constants";\n'

typescript += "\n// ========= Nodes =========\n"
typescript += "export const MDP = new Graph();\n\n"
typescript += "MDP.addNode(new CustomNode(KEY_START, 0, 0, 0, false, [], -1));\n"
typescript += "MDP.addNode(new CustomNode(KEY_DEATH, -5, -5, 0, true, [], -1));\n\n"
for node_name in G.nodes:
    node = cast(N, G.nodes[node_name])
    typescript += node.to_typescript()

typescript += "\n// ========= Edges =========\n"
typescript += 'MDP.addEdge(new CustomEdge(KEY_START, "0_0_0", [["0_0_0", 0.99], [KEY_DEATH, 0.01]], []));\n'
for edge_name in G.edges:
    edge = cast(E, G.edges[edge_name])
    typescript += edge.to_typescript()

typescript += "\n// ========= Level Segments =========\n"
TYPE = "{ [key: string]: string[] }"
typescript += f"export const idToLevel:{TYPE} = {json.dumps(levels, indent=2)};\n"

# Write typescript
with open(os.path.join("..", "src", "levels.ts"), "w") as f:
    f.write(typescript)
