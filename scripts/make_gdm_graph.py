from re import A
from typing import List, cast
import json
import os

from GDM.GDM.Graph import Graph, Node, Edge
from GDM.GDM.utility import bfs

############# Types for the graph #############
class N(Node):
    def __init__(self, name: str, diff: float, enj: float, is_terminal: bool):
        super().__init__(name, 0, 0, False, set())
        self.d = diff
        self.e = enj
        self.depth = 0 # Will be set later

    def to_typescript(self) -> str:
        terminal_str = "true" if self.is_terminal else "false"
        return f"MDP.addNode(new CustomNode('{self.name}', {self.d}, {self.e}, 0, {terminal_str}, [], {self.depth}));\n"

class E(Edge):
    def __init__(self, src: str, tgt: str, link: List[str]):
        super().__init__(src, tgt, [])
        self.link = link

    def to_typescript(self) -> str:
        return f'MDP.addEdge(new CustomEdge("{self.src}", "{self.tgt}", [["{self.tgt}", 0.99], [KEY_DEATH, 0.01]], {self.link}));\n'

G = Graph()

############# Get Links and Levels #############
with open(os.path.join("..", "data", "links.json"), "r") as f:
    links = json.load(f)

with open(os.path.join("..", "data", "levels.json"), "r") as f:
    levels = json.load(f)

    keys = list(levels.keys())
    for id in keys:
        levels[f"{id}_0"] = [row[2:-2] for row in levels[id]]
        del levels[id]


############# Add nodes to the graph #############
with open(os.path.join("..", "data", "level_to_stats.csv"), "r") as f:
    f.readline()  # skip first line
    for line in f.readlines():
        id, difficulty, enjoyability = line.strip().split(",")
        d = float(difficulty) / 7 - 1
        e = float(enjoyability) / 7 - 1
        node_name = f'{id}_0'

        G.add_node(N(f'{id}_0', d, e, False))

# Remove nodes that are terminal
nodes_to_remove = []
for level_id in G.nodes:
    is_terminal = True
    linkKey = level_id.replace("_", ",")
    for tgt in links[linkKey]:
        if links[linkKey][tgt]["tree search"]["percent_playable"] == 1.0:
            is_terminal = False
            break

    if is_terminal:
        print(f"{level_id} is terminal :/")
        nodes_to_remove.append(level_id)

while len(nodes_to_remove) > 0:
    G.remove_node(nodes_to_remove.pop())

############# Build Edges that are Usable #############
for src in links:
    _src = src.replace(",", "_")
    if _src not in G.nodes:
        continue

    for tgt in links[src]:
        info = links[src][tgt]
        tgt = tgt.replace(",", "_")

        if (
            tgt in G.nodes
            and info["tree search"]["percent_playable"] == 1.0
        ):
            G.add_edge(E(_src, tgt, info["tree search"]["link"]) )

############# Find a valid "end" node #############
while True:
    max_bc = -120312903
    max_bc_node = None
    nodes_to_remove = []

    for node_name in G.nodes:
        n = cast(N, G.nodes[node_name])
        bc = n.d + n.e

        if bfs(G, "0_0_0", node_name) != None:
            if bc > max_bc:
                max_bc = bc
                max_bc_node = node_name
        else:
            nodes_to_remove.append(node_name)

    if len(nodes_to_remove) > 0:
        for n in nodes_to_remove:
            print('removing node:', n)
            G.remove_node(n)

        continue

    if max_bc_node in G.nodes:
        end_node = N("end", 0, 0, True)
        end_node.reward = 10
        end_node.is_terminal = True
        G.add_node(end_node)

        G.add_edge(E(cast(str, max_bc_node), "end", []))
        print(f"Edge added: ({max_bc_node}, end)")

        break

############# Run BFS to get the depth each node #############
nodes_to_remove = []
for node_name in G.nodes:
    path = bfs(G, node_name, 'end')

    if path == None:
        print(f'No path to end node found for {node_name}')
        nodes_to_remove.append(node_name)
    else:
        # this should be calculated above, but I am feeling lazy. The reason
        # why I don't check for None is because I already validated that an
        # edge from the beginning node to the current node exists
        cast(N, G.nodes[node_name]).depth = len(bfs(G, '0_0_0', node_name))

while len(nodes_to_remove) > 0:
    G.remove_node(nodes_to_remove.pop())

print(f'{len(G.nodes)} left at the end... not bad!')

############# Hardset 0_0_0 values #############
n = cast(N, G.nodes['0_0_0'])
n.d = -1
n.e = -1

############# Convert Graph into TypeScript #############
typescript = "// Generated by ../scripts/make_gdm_graph.py.py\n"
typescript += 'import { Graph } from "./GDM-TS";\n'
typescript += 'import { CustomNode } from "./customNode";\n'
typescript += 'import { CustomEdge } from "./customEdge";\n'
typescript += 'import { KEY_DEATH, KEY_START } from "./constants";\n'

typescript += "\n// ========= Nodes =========\n"
typescript += "export const MDP = new Graph();\n\n"
typescript += "MDP.addNode(new CustomNode(KEY_START, 0, 0, 0, false, [], -1));\n"
typescript += "MDP.addNode(new CustomNode(KEY_DEATH, -5, -5, 0, true, [], -1));\n\n"
for node_name in G.nodes:
    node = cast(N, G.nodes[node_name])
    typescript += node.to_typescript()

typescript += "\n// ========= Edges =========\n"
typescript += 'MDP.addEdge(new CustomEdge(KEY_START, "0_0_0", [["0_0_0", 0.99], [KEY_DEATH, 0.01]], []));\n'
for edge_name in G.edges:
    edge = cast(E, G.edges[edge_name])
    typescript += edge.to_typescript()

typescript += "\n// ========= Level Segments =========\n"
TYPE = "{ [key: string]: string[] }"
typescript += f"export const idToLevel:{TYPE} = {json.dumps(levels, indent=2)};\n"

# Write typescript
with open(os.path.join("..", "src", "levels.ts"), "w") as f:
    f.write(typescript)
